<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>WebNWB</title>
    <link rel="stylesheet" href="./tutorial-styles.css">
</head>

<body>
    <h1>Getting Started with WebNWB</h1>
    <p>WebNWB is a JavaScript library for reading and writing NWB files in the browser.</p>
    <br>
    <hr><br>
    <section>
        <h2>Tutorial #1: Reading NWB Files</h2>
        <p>In this tutorial, we will show you how to read local and remote NWB files.</p>
    </section>

    <br>
    <hr><br>
    <section>
        <h2>Tutorial #2: Acquiring Data on the Browser</h2>
        <p>In this tutorial, we will show you how to store behavioral and electroencephalography (EEG) data in a NWB
            file while users navigate a webpage.</p>

        <h3>Creating an NWB File</h3>
        <p>Create an NWBFile object with the required fields (session_description, identifier, session_start_time) and
            additional metadata.</p>

        <!-- A codeblock for declaring an NWB File -->
        <pre>
                <code>
import * as nwb from 'webnwb'
const file = nwb.NWBFile({
    sessionDescription: 'EEG data and behavioral data recorded while navigating a webpage.',
    identifier: 'WebNWB_Documentation_Session_' + Math.random().toString(36).substring(7),
    sessionStartTime: Date.now(),
    experimenter: 'Garrett Flynn',
    institution: 'Brains@Play'
})
                </code>
            </pre>

        <h3>Acquiring Behavioral Data</h3>
        <p>SpatialSeries is a subclass of TimeSeries that represents data in space, such as the position of the user's
            cursor over time.</p>

        <p>In SpatialSeries data, the first dimension is always time (in seconds), the second dimension represents the
            x, y position. SpatialSeries data should be stored as one continuous stream as it is acquired, not by trials
            as is often reshaped for analysis.</p>

        <p>We will use the <code>webtrack</code> library to track the user's cursor position in addition to other user
            and page-driven events.</p>
        <!-- A codeblock for listening to events using webtrack -->
        <pre>
                <code>
import * as webtrack from 'webtrack'
const tracker = webtrack.Tracker()

const spatialSeries = nwb.SpatialSeries({
    name: 'cursor',
    description: 'The position (x, y) of the cursor over time.',
    data: [
        [],
        []
    ],
    referenceFrame: '(0,0) is the top-left corner of the visible portion of the page.'
})

const startTime = Date.now()
tracker.start((info) => {
    if (info.type === 'pointermove'){
        const { x, y, timestamp } = info
        spatialSeries.data[0].push(x)
        spatialSeries.data[1].push(y)

        const secondsSincePageLoad = timestamp / 1000
        spatialSeries.timestamps.push(secondsSincePageLoad)
    }
})
                </code>
            </pre>

        <div id="behaviorOutput">
            <p><b>Latest Cursor Position:</b> <span id="cursorX">N/A</span>, <span id="cursorY">N/A</span> (<span
                    id="cursorTime">N/A</span>s)</span></p>
        </div>

        <h3>Storing Behavioral Data to the NWB File</h3>
        <p>To help data analysis and visualization tools know that this SpatialSeries object represents the position of
            the user, store the SpatialSeries object inside a Position object, which can hold one or more SpatialSeries
            objects.</p>
        <pre>
                <!-- NOTE: Check what the correct syntax is -->
                <code>
const position = nwb.Position()
position.addSpatialSeries(spatialSeries)
                </code>
            </pre>

        <p>Create a processing module called "behavior" for storing behavioral data in the NWBFile, then add the
            Position object to the processing module.</p>

        <pre>
                <code>
const behavior = nwb.ProcessingModule({
    description: 'Behavioral data recorded while navigating a webpage.'
})
behavior.addPosition('position', position)
file.addProcessingModule('behavior', behavior)
                </code>
            </pre>

        <h3>Adding Behavioral Events</h3>
        <p>Unlike user behaviors, page events should be stored as BehavioralEvents, which is used to store the timing
            and amount of rewards (e.g. showing an emoji) related to a behavior (e.g. clicking the mouse) </p>
        <pre>
                <code>
const data = []
data.unit = 'ms'
const timeseries = nwb.TimeSeries({
    description: 'The length of time the animation was shown on the page.',
    data: [],
    timestamps: []
})

const emoji = document.createElement('span')
    emoji.innerText = 'ðŸ˜Š'
    emoji.style.transform = 'translate(-50%, -50%)'
    emoji.style.position = 'fixed'
    emoji.style.display = 'none'
    emoji.style.fontSize = '100px'
    emoji.style.zIndex = '1000'
    emoji.style.userSelect = 'none'
    document.body.appendChild(emoji)

    let active = false
    tracker.set('click', (info) => {

        if (!active) {
            emoji.style.display = 'block'
            emoji.style.left = info.x + 'px'
            emoji.style.top = info.y + 'px'
            active = true

            const msToShow = Math.random() * 1000
            setTimeout(() => {
                emoji.style.display = 'none'
                active = false  
            }, msToShow)

            emoji.style.display = 'none'
            timeseries.data.push(msToShow)
            timeseries.timestamps.push(info.timestamp / 1000)
        }
    }) 

const behavioralEvents = nwb.BehavioralEvents()
behavioralEvents.addTimeSeries('buttonPresses', timeseries)

behavior.addDataInterface('behavioralEvents', behavioralEvents)
                </code>
            </pre>

        <h3>Download the NWB File</h3>
        <p>All of the above commands build an NWBFile object in-memory. To download this file, create an NWBHDF5IO
            object to write and download.</p>
        <pre>
                <code>
const filename = 'myFile.nwb'
const io = nwb.NWBHDF5IO()
io.write(file, filename)
io.save(filename) // Saves in browser storage
io.download(filename) // Downloads to the user's computer
                </code>
            </pre>


        <!-- <visualscript-main>

            <visualscript-tab name="Files">
                <section>
                    <div id="options">
                        <button id="file">Load File</button>
                        <button id="get">Download</button>
                        <button id="save">Save</button>
            
                        <br/><br/>
                        <label>Stream Remote Files</label>
                        <input id="streaming" type="checkbox" checked><br/><br/>
            
                        <hr/>
            
                        <h2 id="dandiHeader">DANDI</h3>
                        <span><i id="dandiStatus">Loading dandisets...</i></span>
                        <div id="dandiDiv" style="display:none;">
                            <select id="dandi"></select>
                            <select id="assets"></select>
                            <button id="dandiButton">Get</button>
                        </div>
            
                        <hr/>
            
                        <h3>Samples</h3>
                        <select id="sampleSelect"></select>
                        <button id="sampleButton">Get</button>
                </div>

                    <div id="editorDiv"></div>
                </section>
            </visualscript-tab>
            <visualscript-tab name="Create">
                <section id="create">
                    <button id="increment" class="disabled">Change Data</button>
                </section>
            </visualscript-tab>
        </visualscript-main> -->
    </section>
</body>
<!-- <script src="./demo/dist/index.js" type="module"></script> -->

    <script type="module">
    import * as webtrack from './external/webtrack/index.esm.js'

    const spanX = document.getElementById('cursorX')
    const spanY = document.getElementById('cursorY')
    const spanTime = document.getElementById('cursorTime')

    const tracker = new webtrack.Tracker()
    tracker.start()

    tracker.set('pointermove', (info) => {
        const { x, y, timestamp } = info
        spanTime.innerText = (timestamp / 1000).toFixed(2)
        spanX.innerText = x.toFixed(2)
        spanY.innerText = y.toFixed(2)
    })

    // const emoji = document.getElementById('emoji')
    const emoji = document.createElement('span')
    emoji.innerText = 'ðŸ˜Š'
    emoji.style.transform = 'translate(-50%, -50%)'
    emoji.style.position = 'fixed'
    emoji.style.display = 'none'
    emoji.style.fontSize = '100px'
    emoji.style.zIndex = '1000'
    emoji.style.userSelect = 'none'
    document.body.appendChild(emoji)

    let active = false
    tracker.set('click', (info) => {

        if (!active) {
            emoji.style.display = 'block'
            emoji.style.left = info.x + 'px'
            emoji.style.top = info.y + 'px'
            active = true

            const msToShow = Math.random() * 1000
            setTimeout(() => {
                emoji.style.display = 'none'
                active = false  
            }, msToShow)
        }
    }) 
</script>

</html>